// @strict-types


#Область СлужебныйПрограммныйИнтерфейс

#Область НастройкиЛогирования

// Новые настройки логирования.
// 
// Возвращаемое значение:
//  Структура -  Новые настройки логирования:
// * ВключеноЛогирование - Булево
//
Функция НовыеНастройкиЛогирования() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ВключеноЛогирование",  Ложь);
//	Результат.Вставить("ВключенаТрассировка",  Ложь);
//	Результат.Вставить("ТаймаутЗапросов",      0);
//	Результат.Вставить("ПовторПриОшибкеСоединения", Ложь);
//	Результат.Вставить("СрокХранения", 0);
	Возврат Результат;
	
КонецФункции

// Сохраненные настройки логирования.
// 
// Возвращаемое значение:
//  см. НовыеНастройкиЛогирования
//
Функция ЗагрузитьНастройкиЛогирования() Экспорт
	
	НастройкиЛогирование = НовыеНастройкиЛогирования();
	
	КлючОбъекта = КлючХранилищаНастроекЛогирования();
	НастройкиЛогирование = ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, "Настройки", НастройкиЛогирование);
	
	Возврат НастройкиЛогирование;
	
КонецФункции

// Сохранить использование логирования запросов.
// 
// Параметры:
//  Настройки - Структура:
//
Процедура СохранитьНастройкиЛогирования(Настройки) Экспорт
	
	КлючОбъекта = КлючХранилищаНастроекЛогирования();
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, "Настройки", Настройки);
	
КонецПроцедуры

// Хранилище общих настроек сохранить.
// 
// Параметры:
//  КлючОбъекта - Строка
//  КлючНастроек - Строка
//  ЗначениеНастройки - Произвольный
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, ЗначениеНастройки) Экспорт
	
	Если Метаданные.Подсистемы.Найти("СтандартныеПодсистемы") <> Неопределено Тогда
		МодульОбщегоНазначенияВызовСервера = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияВызовСервера");
		МодульОбщегоНазначенияВызовСервера.ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, ЗначениеНастройки);
		Возврат;
	КонецЕсли;
	
	ХранилищеОбщихНастроек.Сохранить(КлючОбъекта, КлючНастроек, ЗначениеНастройки);
	
КонецПроцедуры

// Хранилище общих настроек загрузить.
// 
// Параметры:
//  КлючОбъекта - Строка
//  КлючНастроек - Строка
//  ЗначениеПоУмолчанию - Произвольный
// 
// Возвращаемое значение:
//  Произвольный -  Хранилище общих настроек загрузить
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию) Экспорт
	
	Если Метаданные.Подсистемы.Найти("СтандартныеПодсистемы") <> Неопределено Тогда
		МодульОбщегоНазначенияВызовСервера = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияВызовСервера");
		Результат = МодульОбщегоНазначенияВызовСервера.ХранилищеОбщихНастроекЗагрузить(
			КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию);
		Возврат Результат;
	КонецЕсли;
	
	Результат = ХранилищеОбщихНастроек.Загрузить(КлючОбъекта, КлючНастроек);
	
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область КонвертацияДанных

// Распаковывае файл формата gzip и возвращает его данные.
// 
// Параметры:
//  ДвоичныеДанные - ДвоичныеДанные - Исходные двоичные данные gzip формата
// 
// Возвращаемое значение:
//  ДвоичныеДанные
//
Функция РаспаковатьФайлGZip(ДвоичныеДанные) Экспорт
	
	РазмерПрефикса = 10;
	РазмерПостфикса = 8;
	РазмерLHF = 34;
	РазмерDD = 16;
	РазмерCDH = 50;
	РазмерEOCD = 22;
	
	ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанные);
	ЧтениеДанных.Пропустить(РазмерПрефикса);
	РазмерДанных = ЧтениеДанных.ИсходныйПоток().Размер();
	
	СжатыйРазмер = РазмерДанных - РазмерПрефикса - РазмерПостфикса;
	НачальнаяЕмкость = РазмерLHF + СжатыйРазмер + РазмерDD + РазмерCDH + РазмерEOCD;
	ПотокВПамяти = Новый ПотокВПамяти(НачальнаяЕмкость);
	
	БуферLHF = Новый БуферДвоичныхДанных(РазмерLHF);
	БуферLHF.ЗаписатьЦелое32(0, 67324752);	// signature 0x04034b50
	БуферLHF.ЗаписатьЦелое16(4, 20);		// version
	БуферLHF.ЗаписатьЦелое16(6, 10);		// bit flags
	БуферLHF.ЗаписатьЦелое16(8, 8);			// compression method
	БуферLHF.ЗаписатьЦелое16(10, 0);		// time
	БуферLHF.ЗаписатьЦелое16(12, 0);		// date
	БуферLHF.ЗаписатьЦелое32(14, 0);		// crc-32
	БуферLHF.ЗаписатьЦелое32(18, 0);		// compressed size
	БуферLHF.ЗаписатьЦелое32(22, 0);		// uncompressed size
	БуферLHF.ЗаписатьЦелое16(26, 4);		// filename length - "data"
	БуферLHF.ЗаписатьЦелое16(28, 0);		// extra field length
	
	КодировкаТекстаСтроки = "ascii";
	ЗаписатьBOM = Ложь;
	БуферASCII = ПолучитьБуферДвоичныхДанныхИзСтроки("data", КодировкаТекстаСтроки, ЗаписатьBOM);
	БуферLHF.Записать(30, БуферASCII);
	
	ЗаписьДанных = Новый ЗаписьДанных(ПотокВПамяти);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БуферLHF);
	ЧтениеДанных.КопироватьВ(ЗаписьДанных, СжатыйРазмер);
	ЗаписьДанных.Close();
	
	ДанныеCRC32 = ЧтениеДанных.ПрочитатьЦелое32();
	НесжатыйРазмер = ЧтениеДанных.ПрочитатьЦелое32();
	ЧтениеДанных.Закрыть();
	
	БуферDD = Новый БуферДвоичныхДанных(РазмерDD);
	БуферDD.ЗаписатьЦелое32(0, 134695760);
	БуферDD.ЗаписатьЦелое32(4, ДанныеCRC32);
	БуферDD.ЗаписатьЦелое32(8, СжатыйРазмер);
	БуферDD.ЗаписатьЦелое32(12, НесжатыйРазмер);
	
	БуферCDH = Новый БуферДвоичныхДанных(РазмерCDH);
	БуферCDH.ЗаписатьЦелое32(0, 33639248);			// signature 0x02014b50
	БуферCDH.ЗаписатьЦелое16(4, 798);				// version made by
	БуферCDH.ЗаписатьЦелое16(6, 20);				// version needed to extract
	БуферCDH.ЗаписатьЦелое16(8, 10);				// bit flags
	БуферCDH.ЗаписатьЦелое16(10, 8);				// compression method
	БуферCDH.ЗаписатьЦелое16(12, 0);				// time
	БуферCDH.ЗаписатьЦелое16(14, 0);				// date
	БуферCDH.ЗаписатьЦелое32(16, ДанныеCRC32);		// crc-32
	БуферCDH.ЗаписатьЦелое32(20, СжатыйРазмер);		// compressed size
	БуферCDH.ЗаписатьЦелое32(24, НесжатыйРазмер);	// uncompressed size
	БуферCDH.ЗаписатьЦелое16(28, 4);				// file name length
	БуферCDH.ЗаписатьЦелое16(30, 0);  				// extra field length
	БуферCDH.ЗаписатьЦелое16(32, 0);				// file comment length
	БуферCDH.ЗаписатьЦелое16(34, 0);				// disk number start
	БуферCDH.ЗаписатьЦелое16(36, 0);				// internal file attributes
	БуферCDH.ЗаписатьЦелое32(38, 2176057344);		// external file attributes
	БуферCDH.ЗаписатьЦелое32(42, 0);				// relative offset of local header
	БуферCDH.Записать(46, БуферASCII);
	
	БуферEOCD = Новый БуферДвоичныхДанных(РазмерEOCD);
	БуферEOCD.ЗаписатьЦелое32(0, 101010256);		// signature 0x06054b50
	БуферEOCD.ЗаписатьЦелое16(4, 0);				// number of this disk
	БуферEOCD.ЗаписатьЦелое16(6, 0);				// number of the disk with the start of the central directory
	БуферEOCD.ЗаписатьЦелое16(8, 1);				// total number of entries in the central directory on this disk
	БуферEOCD.ЗаписатьЦелое16(10, 1);				// total number of entries in the central directory
	БуферEOCD.ЗаписатьЦелое32(12, РазмерCDH);		// size of the central directory
										// offset of start of central directory with respect to the starting disk number
	БуферEOCD.ЗаписатьЦелое32(16, РазмерLHF + СжатыйРазмер + РазмерDD); 
	БуферEOCD.ЗаписатьЦелое16(20, 0);				// the starting disk number
	
	ЗаписьДанных = Новый ЗаписьДанных(ПотокВПамяти);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БуферDD);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БуферCDH);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БуферEOCD);
	ЗаписьДанных.Close();
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ЧтениеZipФайла = Новый ЧтениеZipФайла(ПотокВПамяти);
	Элемент = ЧтениеZipФайла.Элементы.Получить(0);
	ЧтениеZipФайла.Извлечь(Элемент, ИмяВременногоФайла, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ЧтениеZipФайла.Закрыть();
	
	РазделительПути = ПолучитьРазделительПути();
	ПутьКФайлу = СтрШаблон("%1%2%3", ИмяВременногоФайла, РазделительПути, Элемент.Имя);
	Результат = Новый ДвоичныеДанные(ПутьКФайлу);
	
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат Результат;
	
КонецФункции

Функция СоответствиеВТаблицуЗначений(Соответствие, КолонкаКлюча, КолонкаЗначения) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить(КолонкаКлюча);
	Таблица.Колонки.Добавить(КолонкаЗначения);
	
	Если Соответствие = Неопределено Тогда
		Возврат Таблица;
	КонецЕсли;
	
	Для каждого ЭлементКоллекции Из Соответствие Цикл
		НоваяСтрока = Таблица.Добавить();
		НоваяСтрока[КолонкаКлюча] = ЭлементКоллекции.Ключ;
		НоваяСтрока[КолонкаЗначения] = ЭлементКоллекции.Значение;
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

// Получение данных из строки в формате JSON.
// 
// Параметры:
// 	Значение - Строка - строка JSON
// 	СвойстваСДатой - Строка - именя свойстсв с датой через запятую.
// 	
// Возвращаемое значение:
// 	Произвольный
//
Функция ЗначениеИзСтрокиJSON(Знач Значение, СвойстваСДатой = "") Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка")
		Или ПустаяСтрока(Значение)
		Или Лев(Значение, 1) = "<" Тогда
		Возврат Значение;
	КонецЕсли;
	
	Результат = Неопределено;
	ЧтениеJSON = Новый ЧтениеJSON;
	Попытка
		ЧтениеJSON.УстановитьСтроку(Значение);
		Результат = ПрочитатьJSON(ЧтениеJSON, , СвойстваСДатой);
		ЧтениеJSON.Закрыть();
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Значение ВJSON.
// 
// Параметры:
//  Данные - Произвольный
// 
// Возвращаемое значение:
//  Строка
//
Функция ЗначениеВJSON(Знач Данные) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Данные);
	Значение = ЗаписьJSON.Закрыть();
	
	Возврат Значение;
	
КонецФункции

#КонецОбласти

#Область Конструкторы

Функция НаименованиеБиблиотеки() Экспорт
	Возврат НСтр("ru = 'OneSniffer.'", ОбщегоНазначения.КодОсновногоЯзыка());
КонецФункции

Функция СобытиеВызватьHTTPМетод() Экспорт
	
	СобытиеШаблон = НСтр("ru = '%1ВызватьHTTPМетод'", ОбщегоНазначения.КодОсновногоЯзыка());
	Событие = СтрШаблон(СобытиеШаблон, НаименованиеБиблиотеки());
	Возврат Событие;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Имя события.
// 
// Параметры:
//  ИмяСобытия - Строка
//  АдресРесурса - Строка
//
Процедура ИмяСобытия(ИмяСобытия, АдресРесурса) Экспорт
	
	ЛогированиеТрафикаПереопределяемый.ИмяСобытия(ИмяСобытия, АдресРесурса);
	
	Если ПустаяСтрока(ИмяСобытия) Тогда
		
		Если СтрНачинаетсяС(АдресРесурса, "rest/public/ticket/get") Тогда
			ИмяСобытия = "ИнтернетПоддержка.Получение тикета";
		ИначеЕсли АдресРесурса = "update-platform/programs/update/info" Тогда
			ИмяСобытия = "ИнтернетПоддержка.Обновление платформы";
		ИначеЕсли АдресРесурса = "update-platform/patches/getInfo" Тогда
			ИмяСобытия = "ИнтернетПоддержка.Проверка патчей платформы";
		ИначеЕсли АдресРесурса = "update-platform/programs/update/ping" Тогда
			ИмяСобытия = "ИнтернетПоддержка.Доступность обновления";
		Иначе
			ИмяСобытия = НСтр("ru = 'Произвольный запрос'");
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Ключ хранилища настроек логирования.
// 
// Возвращаемое значение:
//  Строка -  Ключ хранилища настроек логирования
Функция КлючХранилищаНастроекЛогирования() Экспорт
	Возврат "OneSniff";
КонецФункции

// Получение информации запроса.
//
// Параметры:
//  КлючЗаписи - Структура - отоборы для логов.
// 
// Возвращаемое значение:
//  Структура - информация запроса:
//   * ТелоЗапроса - Строка - тело запроса.
//
Функция ПолучитьДетализациюПротоколаЗапроса(КлючЗаписи) Экспорт
	
	РазмерСтроки = 1000;
	
	ПротоколЗапроса = ПолучитьПротоколЗапросаЛога(КлючЗаписи);
	Если ПротоколЗапроса = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПротоколЗапроса.Вставить("ПредставлениеТелоЗапроса");
	ПротоколЗапроса.Вставить("ПредставлениеТелоОтвета");
	ПротоколЗапроса.Вставить("ДеревоЗапроса");
	ПротоколЗапроса.Вставить("ДеревоОтвета");
	
	ТипКонтентаЗапроса = "";
	Если КонтентСодержитТекст(ПротоколЗапроса.ЗаголовкиЗапроса, ТипКонтентаЗапроса) Тогда
		ПротоколЗапроса.ПредставлениеТелоЗапроса = ПолучитьПредставлениеТела(ПротоколЗапроса.ТелоЗапроса, РазмерСтроки);
	Иначе
		ПротоколЗапроса.ПредставлениеТелоЗапроса = ПолучитьПредставлениеТела(ПротоколЗапроса.ТелоЗапроса,, Истина);
	КонецЕсли;
	
	Если СтрНайти(ТипКонтентаЗапроса, "json") Тогда
		ПротоколЗапроса.ДеревоЗапроса = ПолучитьДеревоЗначенийИзJSON(ПротоколЗапроса.ТелоЗапроса, Истина);
	КонецЕсли;
	
	ТипКонтентаОтвета = "";
	Если КонтентСодержитТекст(ПротоколЗапроса.ЗаголовкиОтвета, ТипКонтентаОтвета) Тогда
		ПротоколЗапроса.ПредставлениеТелоОтвета = ПолучитьПредставлениеТела(ПротоколЗапроса.ТелоОтвета, РазмерСтроки);
	Иначе
		ПротоколЗапроса.ПредставлениеТелоОтвета = ПолучитьПредставлениеТела(ПротоколЗапроса.ТелоОтвета,, Истина);
	КонецЕсли;
	Если СтрНайти(ТипКонтентаОтвета, "json") Тогда
		ПротоколЗапроса.ДеревоОтвета = ПолучитьДеревоЗначенийИзJSON(ПротоколЗапроса.ТелоОтвета, Истина);
	КонецЕсли;
	
	Возврат ПротоколЗапроса;
	
КонецФункции

// Получить протокол запроса лога.
//
// Параметры:
//  КлючЗаписи	 - Структура - ключи записи регистра сведений ЛогиТрафика.
// 
// Возвращаемое значение:
//  Структура - см. НовыйПротоколЗапросаHTTP.
//
Функция ПолучитьПротоколЗапросаЛога(Знач КлючЗаписи) Экспорт
		
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ЛогиТрафика.Событие КАК Событие,
	|	ЛогиТрафика.Дата КАК Дата,
	|	ЛогиТрафика.Метод КАК Метод,
	|	ЛогиТрафика.Сервер КАК Сервер,
	|	ЛогиТрафика.Порт КАК Порт,
	|	ЛогиТрафика.Адрес КАК Адрес,
	|	ЛогиТрафика.ЭтоЗащищенноеСоединение КАК ЭтоЗащищенноеСоединение,
	|	ЛогиТрафика.КодОтвета КАК КодОтвета,
	|	ЛогиТрафика.Длительность КАК Длительность,
	|	ЛогиТрафика.Клиент КАК Клиент,
	|	ЛогиТрафика.Содержание КАК Содержание,
	|	ЛогиТрафика.ВремяНачала КАК ВремяНачала,
	|	ЛогиТрафика.Входящий КАК Входящий
	|ИЗ
	|	РегистрСведений.ЛогиТрафика КАК ЛогиТрафика
	|ГДЕ
	|	ЛогиТрафика.ВремяНачала = &ВремяНачала
	|	И ЛогиТрафика.Сервер = &Сервер";
	Запрос.УстановитьПараметр("Сервер",      КлючЗаписи.Сервер);
	Запрос.УстановитьПараметр("ВремяНачала", КлючЗаписи.ВремяНачала);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Не Выборка.Следующий() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПротоколЗапроса = НовыйПротоколЗапросаHTTP();
	
	ЗаполнитьЗначенияСвойств(ПротоколЗапроса, Выборка);
	
	Содержание = Выборка.Содержание.Получить();
	Если ТипЗнч(Содержание) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(ПротоколЗапроса, Содержание);
	КонецЕсли;
	
	Возврат ПротоколЗапроса;
	
КонецФункции

Функция НовыйПротоколЗапросаHTTP()
		
	ПротоколЗапроса = Новый Структура;
	ПротоколЗапроса.Вставить("Событие",   "");
	ПротоколЗапроса.Вставить("Дата",      Дата(1,1,1));
	ПротоколЗапроса.Вставить("ВремяНачала", 0);
	ПротоколЗапроса.Вставить("Клиент",    "");
	ПротоколЗапроса.Вставить("Метод",     "");
	ПротоколЗапроса.Вставить("Сервер",    "");
	ПротоколЗапроса.Вставить("Порт",      0);
	ПротоколЗапроса.Вставить("Адрес",     "");
	ПротоколЗапроса.Вставить("ЭтоЗащищенноеСоединение", Ложь);
	ПротоколЗапроса.Вставить("ЗаголовкиЗапроса", Новый Соответствие);
	ПротоколЗапроса.Вставить("ТелоЗапроса",      Неопределено);
	ПротоколЗапроса.Вставить("ТелоЗапросаСтрокой", "");
	ПротоколЗапроса.Вставить("Логин",     Неопределено);
	ПротоколЗапроса.Вставить("Пароль",    Неопределено);
	ПротоколЗапроса.Вставить("Прокси",    Неопределено);
	ПротоколЗапроса.Вставить("КодОтвета",    0);
	ПротоколЗапроса.Вставить("РазмерОтвета", 0);
	ПротоколЗапроса.Вставить("Длительность", 0);
	ПротоколЗапроса.Вставить("ЗаголовкиОтвета", Новый Соответствие);
	ПротоколЗапроса.Вставить("ТелоОтвета",      Неопределено);
	ПротоколЗапроса.Вставить("ТелоОтветаСтрокой",      "");
	ПротоколЗапроса.Вставить("Таймаут",         Неопределено);
	ПротоколЗапроса.Вставить("ПолныйТекст",     "");
	ПротоколЗапроса.Вставить("Входящий",        Ложь);
	
	Возврат ПротоколЗапроса;
	
КонецФункции

Функция КонтентСодержитТекст(Знач Заголовки, ТипКонтента = "")
	
	ТипКонтента = "";
	Если ТипЗнч(Заголовки) = Тип("Соответствие") Или ТипЗнч(Заголовки) = Тип("ФиксированноеСоответствие") Тогда
		ТипКонтента = НРег(Заголовки.Получить("Content-Type"));
		Если ПустаяСтрока(ТипКонтента) Тогда // Обход, когда заголовок в нижнем регистре.
			ТипКонтента = НРег(Заголовки.Получить("content-type"));
		КонецЕсли;
	КонецЕсли;
	
	Если ТипКонтента = ""
		Или СтрНайти(ТипКонтента, "text")
		Или СтрНайти(ТипКонтента, "json")
		Или СтрНайти(ТипКонтента, "xml")
		Или СтрНайти(ТипКонтента, "x-www-form-urlencoded") Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция ПолучитьПредставлениеТела(Значение, РазмерСтроки = Неопределено, ПолучитьBase64 = Ложь)
	
	Результат = Значение;
	Если ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда
		// Новый формат получения
		Если Не ПолучитьBase64 Тогда
			Результат = ПолучитьСтрокуИзДвоичныхДанных(Значение, КодировкаТекста.UTF8);
			//Результат = ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(ПолучитьСтрокуИзДвоичныхДанных(Значение, КодировкаТекста.UTF8)))
		Иначе
			Результат = Base64Строка(Значение);
		КонецЕсли;

	КонецЕсли;
	
	Если РазмерСтроки <> Неопределено И ТипЗнч(Результат) = Тип("Строка") И СтрДлина(Результат) > РазмерСтроки Тогда
		Результат = Лев(Результат, РазмерСтроки) + "...";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьДеревоЗначенийИзJSON(Значение, ПрочитатьВСоответствие = Ложь)
	
	Если ПустаяСтрока(Значение) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый ДеревоЗначений;
	Результат.Колонки.Добавить("Значение");
	
	ЧтениеJSON = Новый ЧтениеJSON;
	Попытка
		Если ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда
			// Новый формат получения
			Тело = ПолучитьСтрокуИзДвоичныхДанных(Значение, КодировкаТекста.UTF8);
		ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
			Тело = Значение;
		Иначе
			НоваяСтрока = Результат.Строки.Добавить();
			НоваяСтрока.Значение = Значение;
			Возврат Результат;
		КонецЕсли;
		
		Если ПустаяСтрока(Тело) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ЧтениеJSON.УстановитьСтроку(Тело);
		ДанныеТела = ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие);
		ЧтениеJSON.Закрыть();
		Если ЗначениеЗаполнено(ДанныеТела) Тогда
			ЗаполнитьДеревоВРекурсии(Результат, ДанныеТела);
		КонецЕсли;
	Исключение
		Если СтрДлина(Тело) > 500 Тогда
			Тело = Лев(Тело, 500) + "...";
		КонецЕсли;
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации("Чтение JSON", УровеньЖурналаРегистрации.Предупреждение,
			Метаданные.РегистрыСведений.ЛогиТрафика,, ТекстОшибки + Символы.ПС + Тело);
		НоваяСтрока = Результат.Строки.Добавить();
		НоваяСтрока.Значение = "<Ошибка чтения JSON>";
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьДеревоВРекурсии(СтрокаДерева, Значение)
	
	Если ТипЗнч(Значение) = Тип("Структура")
		Или ТипЗнч(Значение) = Тип("Массив")
		Или ТипЗнч(Значение) = Тип("Соответствие") Тогда
		ОднаСтрока = Значение.Количество() = 1;
		Если ТипЗнч(СтрокаДерева) <> Тип("ДеревоЗначений") Тогда
			Если ТипЗнч(Значение) = Тип("Массив") Тогда
				СтрокаДерева.Значение = "[]";
			ИначеЕсли ТипЗнч(Значение) = Тип("Структура") Или ТипЗнч(Значение) = Тип("Соответствие") Тогда
				СтрокаДерева.Значение = "{}";
			КонецЕсли;
		КонецЕсли;
		ПерваяСтрока = Истина;
		Для каждого ЭлементКоллекции Из Значение Цикл
			// Если одна строка или в составе коллекция то не группируем.
			Если (ОднаСтрока 
				Или ТипЗнч(ЭлементКоллекции) = Тип("Структура") 
				Или ТипЗнч(ЭлементКоллекции) = Тип("Соответствие")
				Или ТипЗнч(ЭлементКоллекции) = Тип("Массив")) Тогда
					Если ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений") Тогда
						НоваяСтрока = СтрокаДерева.Строки.Добавить();
					ИначеЕсли Значение.Количество() = 1 Тогда
						НоваяСтрока = СтрокаДерева;
					ИначеЕсли СтрокаДерева.Родитель = Неопределено Тогда
						НоваяСтрока = СтрокаДерева.Строки.Добавить();
					ИначеЕсли ПерваяСтрока Тогда
						НоваяСтрока = СтрокаДерева;
					Иначе
						НоваяСтрока = СтрокаДерева.Родитель.Строки.Добавить();
					КонецЕсли;
			Иначе
				НоваяСтрока = СтрокаДерева.Строки.Добавить();
			КонецЕсли;
			ЗаполнитьДеревоВРекурсии(НоваяСтрока, ЭлементКоллекции);
			ПерваяСтрока = Ложь;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Значение) = Тип("КлючИЗначение") Тогда
		Если ТипЗнч(Значение.Значение) = Тип("Структура")
			Или ТипЗнч(Значение.Значение) = Тип("Соответствие")
			Или ТипЗнч(Значение.Значение) = Тип("Массив") Тогда
			СтрокаДерева.Значение = Значение.Ключ;
			НоваяСтрока = СтрокаДерева.Строки.Добавить();
			ЗаполнитьДеревоВРекурсии(НоваяСтрока, Значение.Значение);
		Иначе
			Данные = Значение.Значение;
			Если ТипЗнч(Данные) = Тип("Число") Тогда
				Данные = Формат(Данные, "ЧГ=");
			ИначеЕсли ТипЗнч(Данные) = Тип("Строка") Тогда
				Данные = """" + Данные + """";
			КонецЕсли;
			СтрокаДерева.Значение = Значение.Ключ + ": " + Данные;
		КонецЕсли;
	Иначе
		Если ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений") Тогда
			НоваяСтрока = СтрокаДерева.Строки.Добавить();
			НоваяСтрока.Значение = Значение;
		Иначе
			СтрокаДерева.Значение = Значение;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьСтрокуURLЗапроса(Метод, Сервер, ЗащищенноеСоединение, Порт, Адрес, ИсключитьПараметры = Ложь) Экспорт
	
	СтрокаПорт = ?(Не ЗначениеЗаполнено(Порт) Или Порт = 80 Или Порт = 443, "", ":" + Формат(Порт, "ЧГ="));
	Результат = "" + ?(Метод = "", "", ВРег(Метод) + " ")
		+ ?(ЗащищенноеСоединение = Неопределено Или ЗащищенноеСоединение = Ложь, "http://", "https://")
		+ Сервер + СтрокаПорт + ?(Лев(Адрес, 1) = "/", "", "/") + Адрес;
		
	Если ИсключитьПараметры Тогда
		РазделительПараметры = СтрНайти(Результат, "?");
		Если РазделительПараметры <> 0 Тогда
			Результат = Лев(Результат, РазделительПараметры - 1);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получить текст лога.
//
// Параметры:
//  КлючЗаписи		 - Структура - ключи записи регистра сведений ЛогиТрафика
//  ВключатьОтвет	 - Булево - признак включения ответа запроса.
// 
// Возвращаемое значение:
//  Строка - содержание записи лога.
//
Функция ПолучитьТекстЛога(КлючЗаписи, ВключатьОтвет = Ложь, БезАвторизации = Ложь) Экспорт
	
	ПротоколЗапроса = ПолучитьПротоколЗапросаЛога(КлючЗаписи);
	Если ПротоколЗапроса = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Текст = Новый ТекстовыйДокумент;
	
	Текст.ДобавитьСтроку("### " + ПротоколЗапроса.Событие + ?(ПротоколЗапроса.Входящий, " [incoming]", ""));
	Текст.ДобавитьСтроку(ПолучитьСтрокуURLЗапроса(ПротоколЗапроса.Метод, ПротоколЗапроса.Сервер,
		ПротоколЗапроса.ЭтоЗащищенноеСоединение, ПротоколЗапроса.Порт, ПротоколЗапроса.Адрес));
	
	ЗаголовкиЗапроса = ПротоколЗапроса.ЗаголовкиЗапроса;
	Если ЗначениеЗаполнено(ЗаголовкиЗапроса) Тогда
		Для каждого ЭлементКоллекции Из ЗаголовкиЗапроса Цикл
			Если БезАвторизации И ЭлементКоллекции.Ключ = "Authorization" Тогда
				Продолжить;
			КонецЕсли;
			Текст.ДобавитьСтроку(ЭлементКоллекции.Ключ + ": " + ЭлементКоллекции.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПротоколЗапроса.ТелоЗапроса) Тогда
		Текст.ДобавитьСтроку("");
		Текст.ДобавитьСтроку(ПолучитьПредставлениеТела(ПротоколЗапроса.ТелоЗапроса,, Не КонтентСодержитТекст(ПротоколЗапроса.ЗаголовкиЗапроса)));
	КонецЕсли;
	
	Если ВключатьОтвет Тогда
		Текст.ДобавитьСтроку("");
		ВставкаСодержимогоОтветаВПротокол(Текст, ПротоколЗапроса);
	КонецЕсли;
	
	Возврат Текст.ПолучитьТекст();
	
КонецФункции

Процедура ВставкаСодержимогоОтветаВПротокол(Текст, ПротоколЛогЗапроса)
	
	Если ПротоколЛогЗапроса.Свойство("HTTPОтвет") = Ложь Тогда
		КодОтвета = ПротоколЛогЗапроса.КодОтвета;
		ТелоОтвета = ПротоколЛогЗапроса.ТелоОтвета;
		ЗаголовкиОтвета = ПротоколЛогЗапроса.ЗаголовкиОтвета;
	Иначе
		КодОтвета = ПротоколЛогЗапроса.HTTPОтвет.КодСостояния;
		ТелоОтвета = ПротоколЛогЗапроса.HTTPОтвет.ПолучитьТелоКакДвоичныеДанные();
	КонецЕсли;
	
	Текст.ДобавитьСтроку(
		СтрШаблон("# HTTP/1.1 %1 %2 - %3.%4 (%5 sec)%6",
			Формат(КодОтвета, "ЧН="),
			РасшифровкаКодаСостоянияHTTP(КодОтвета),
			Формат(ПротоколЛогЗапроса.Дата, "ДФ='dd.MM.yyyy HH:mm:ss'"),
			Формат(ПротоколЛогЗапроса.ВремяНачала%1000, "ЧЦ=3; ЧВН="),
			Формат(ПротоколЛогЗапроса.Длительность, "ЧДЦ=3; ЧН=0")));
	Если ЗначениеЗаполнено(ЗаголовкиОтвета) Тогда
		Для каждого ЭлементКоллекции Из ЗаголовкиОтвета Цикл
			Текст.ДобавитьСтроку(Символы.Таб + ЭлементКоллекции.Ключ + ": " + ЭлементКоллекции.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТелоОтвета) Тогда
		Текст.ДобавитьСтроку(Символы.Таб);
		ПредставлениеТелаОтвета = ПолучитьПредставлениеТела(ТелоОтвета,, Не КонтентСодержитТекст(ЗаголовкиОтвета));
		ПредставлениеТелаОтвета = Символы.Таб + СтрЗаменить(ПредставлениеТелаОтвета, Символы.ПС, Символы.ПС + Символы.Таб);
		
		Представление = Новый ТекстовыйДокумент;
		Представление.УстановитьТекст(ПредставлениеТелаОтвета);
		Для НомерСтроки = 1 По Представление.КоличествоСтрок() Цикл
			СтрокаПредставления = Представление.ПолучитьСтроку(НомерСтроки);
			Текст.ДобавитьСтроку(СтрокаПредставления);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Функция РасшифровкаКодаСостоянияHTTP(КодСостояния) Экспорт
	
	Если  КодСостояния = 200 Тогда Расшифровка = "ОК"
	ИначеЕсли КодСостояния = 304 Тогда Расшифровка = "Not Modified"
	ИначеЕсли КодСостояния = 400 Тогда Расшифровка = "Bad Request"
	ИначеЕсли КодСостояния = 401 Тогда Расшифровка = "Unauthorized"
	ИначеЕсли КодСостояния = 402 Тогда Расшифровка = "Payment Required"
	ИначеЕсли КодСостояния = 403 Тогда Расшифровка = "Forbidden"
	ИначеЕсли КодСостояния = 404 Тогда Расшифровка = "Not Found"
	ИначеЕсли КодСостояния = 405 Тогда Расшифровка = "Method Not Allowed"
	ИначеЕсли КодСостояния = 406 Тогда Расшифровка = "Not Acceptable"
	ИначеЕсли КодСостояния = 407 Тогда Расшифровка = "Proxy Authentication Required"
	ИначеЕсли КодСостояния = 408 Тогда Расшифровка = "Request Timeout"
	ИначеЕсли КодСостояния = 409 Тогда Расшифровка = "Conflict"
	ИначеЕсли КодСостояния = 410 Тогда Расшифровка = "Gone"
	ИначеЕсли КодСостояния = 411 Тогда Расшифровка = "Length Required"
	ИначеЕсли КодСостояния = 412 Тогда Расшифровка = "Precondition Failed"
	ИначеЕсли КодСостояния = 413 Тогда Расшифровка = "Request Entity Too Large"
	ИначеЕсли КодСостояния = 414 Тогда Расшифровка = "Request-URL Too Long"
	ИначеЕсли КодСостояния = 415 Тогда Расшифровка = "Unsupported Media-Type"
	ИначеЕсли КодСостояния = 416 Тогда Расшифровка = "Requested Range Not Satisfiable"
	ИначеЕсли КодСостояния = 417 Тогда Расшифровка = "Expectation Failed"
	ИначеЕсли КодСостояния = 429 Тогда Расшифровка = "Too Many Requests"
	ИначеЕсли КодСостояния = 500 Тогда Расшифровка = "Internal Server Error"
	ИначеЕсли КодСостояния = 501 Тогда Расшифровка = "Not Implemented"
	ИначеЕсли КодСостояния = 502 Тогда Расшифровка = "Bad Gateway"
	ИначеЕсли КодСостояния = 503 Тогда Расшифровка = "Server Unavailable"
	ИначеЕсли КодСостояния = 504 Тогда Расшифровка = "Gateway Timeout"
	ИначеЕсли КодСостояния = 505 Тогда Расшифровка = "HTTP Version Not Supported"
	ИначеЕсли КодСостояния = 506 Тогда Расшифровка = "Variant Also Negotiates"
	ИначеЕсли КодСостояния = 507 Тогда Расшифровка = "Insufficient Storage"
	ИначеЕсли КодСостояния = 509 Тогда Расшифровка = "Bandwidth Limit Exceeded"
	ИначеЕсли КодСостояния = 510 Тогда Расшифровка = "Not Extended"
	ИначеЕсли КодСостояния = 511 Тогда Расшифровка = "Network Authentication Required"
	Иначе                              Расшифровка = "Unknow code answer";
	КонецЕсли;
	
	Возврат Расшифровка;
	
КонецФункции

Процедура ЗагрузитьЛогиHTTPИзФайла(Знач Адрес, Отказ = Ложь, ТекстОшибки = "") Экспорт
	
	Если ЭтоАдресВременногоХранилища(Адрес) Тогда
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(Адрес);
		Текст = ПолучитьСтрокуИзДвоичныхДанных(ДвоичныеДанные);
		
		// Обход ошибки платформы выгрузки CR CR LF //* TODO Написать разработчикам платформы!
		Текст = СтрЗаменить(Текст, Символы.ВК + Символы.ПС, Символы.ПС);
	Иначе
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.Прочитать(Адрес);
		Текст = ТекстовыйДокумент.ПолучитьТекст();
	КонецЕсли;
	
	ПротоколыЗапросов = ПрочитатьПротоколыЗапросовИзСтроки(Текст, Отказ, ТекстОшибки);
	Если Отказ Тогда
		Возврат;
	КонецЕсли;
	
	НачатьТранзакцию();
	Для каждого ПротоколЗапроса Из ПротоколыЗапросов Цикл
			
		Запись = РегистрыСведений.ЛогиHTTP.СоздатьМенеджерЗаписи();
		ЗаполнитьЗначенияСвойств(Запись, ПротоколЗапроса);
		Запись.Прочитать();
		Если Запись.Выбран() Тогда
			Отказ = Истина;
			ТекстОшибки = СтрШаблон(НСтр("ru = 'Дубль лога, см. %1'"), ПротоколЗапроса.Событие);
			Прервать;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Запись, ПротоколЗапроса);
		Содержание = НовоеСодержаниеЗапроса();
		Содержание.ЗаголовкиЗапроса = ПротоколЗапроса.ЗаголовкиЗапроса;
		Содержание.ТелоЗапроса = ПротоколЗапроса.ТелоЗапроса;
		Содержание.ЗаголовкиОтвета = ПротоколЗапроса.ЗаголовкиОтвета;
		Содержание.ТелоОтвета = ПротоколЗапроса.ТелоОтвета;
		Запись.Содержание = Новый ХранилищеЗначения(Содержание, Новый СжатиеДанных(5));
		Запись.Записать(Истина);
		
	КонецЦикла;
		
	Если Не Отказ Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли;
	
КонецПроцедуры

Функция ПрочитатьПротоколыЗапросовИзСтроки(Знач ТекстЗапроса, Отказ = Ложь, ТекстОшибки = Неопределено)
	
	СписокЗапросов = Новый Массив;
	
	Текст = Новый ТекстовыйДокумент;
	Текст.УстановитьТекст(ТекстЗапроса);
	
	Если СтрНайти(ТекстЗапроса, "### ") = 0  Тогда
		Текст.ВставитьСтроку(0, "### ЛогированиеТрафика.ПроизвольныйЗапрос");
	КонецЕсли;
	
	ПротоколЗапроса = НовыйПротоколЗапросаHTTP();
	
	Для НомерСтроки = 1 По Текст.КоличествоСтрок() Цикл
		
		Стр = Текст.ПолучитьСтроку(НомерСтроки);
		
		Если СтрНачинаетсяС(Стр, "### ") Тогда
			Если ЗначениеЗаполнено(ПротоколЗапроса.Адрес) Тогда
				ПротоколЗапроса.ТелоЗапроса = ПолучитьДвоичныеДанныеИзСтроки(ПротоколЗапроса.ТелоЗапросаСтрокой);
				СписокЗапросов.Добавить(ПротоколЗапроса);
				ПротоколЗапроса = НовыйПротоколЗапросаHTTP();
			КонецЕсли;
			КлючВходящий = " [incoming]";
			Если СтрНайти(Стр, КлючВходящий) Тогда
				ПротоколЗапроса.Входящий = Истина;
				Стр = СтрЗаменить(Стр, КлючВходящий, "");
			КонецЕсли;
			ПротоколЗапроса.Событие = ПротоколЗапроса.Событие + Сред(Стр, 5);
			НомерСтроки = НомерСтроки + 1;
			Стр = Текст.ПолучитьСтроку(НомерСтроки);
			
			// Прочитать адрес запроса в протокол
			ИндексПервогоПробела = СтрНайти(Стр, " ");
			Метод = ВРег(Лев(Стр, ИндексПервогоПробела - 1));
			АдресЗапроса = Сред(Стр, ИндексПервогоПробела + 1);
			Если Не ЗначениеЗаполнено(ПротоколЗапроса.Метод) И Не ПустаяСтрока(АдресЗапроса) Тогда
				Если Метод <> "" И СтрНайти("GET, POST, PATCH, DELETE, PUT", Метод) Тогда
					ПротоколЗапроса.Метод = Метод;
					СтруктураАдреса = СтруктураURI(АдресЗапроса);
					ПротоколЗапроса.Сервер = СтруктураАдреса.Хост;
					ПротоколЗапроса.Адрес = "/" + СтруктураАдреса.ПутьНаСервере;
					ПротоколЗапроса.Порт = СтруктураАдреса.Порт;
					ПротоколЗапроса.ЭтоЗащищенноеСоединение = ?(НРег(СтруктураАдреса.Схема) = "https", Истина, Ложь);
				КонецЕсли;
			КонецЕсли;
			СоединитьСтроки(ПротоколЗапроса.ПолныйТекст, Стр);
			
			// Прочитать заголовки.
			Пока НомерСтроки <= Текст.КоличествоСтрок() Цикл
				НомерСтроки = НомерСтроки + 1;
				Стр = Текст.ПолучитьСтроку(НомерСтроки);
				ИндексРазделителя = СтрНайти(Стр, ": ");
				Если ИндексРазделителя = 0 Тогда
					Прервать;
				КонецЕсли;
				СоединитьСтроки(ПротоколЗапроса.ПолныйТекст, Стр);
				ПротоколЗапроса.ЗаголовкиЗапроса.Вставить(Лев(Стр, ИндексРазделителя - 1),
					Сред(Стр, ИндексРазделителя + 2));
			КонецЦикла;
		КонецЕсли;
		
		// Проверка на ответ.
		Если СтрНачинаетсяС(Стр, "# HTTP") Тогда
			ПрочитатьЗаголовокОтветаВПротоколЗапроса(Сред(Стр, 3), ПротоколЗапроса);
			ОжидаемЗаголовкиОтвета = Истина;
			Если СтрНайти(Стр, "ERROR") = Истина Тогда
				ОжидаемЗаголовкиОтвета = Ложь;
			КонецЕсли;
			
			ТекстОтвета = Новый ТекстовыйДокумент;
			Пока НомерСтроки <= Текст.КоличествоСтрок() Цикл
				НомерСтроки = НомерСтроки + 1;
				Стр = Текст.ПолучитьСтроку(НомерСтроки);
				Если Лев(Стр, 1) <> Символы.Таб Тогда
					Прервать;
				КонецЕсли;
				Если Стр = Символы.Таб Тогда
					Если ОжидаемЗаголовкиОтвета Тогда
						ОжидаемЗаголовкиОтвета = Ложь;
					КонецЕсли;
					Продолжить;
				КонецЕсли;
				Если ОжидаемЗаголовкиОтвета Тогда
					Раздел = СтрНайти(Стр, ": ");
					Если Раздел > 0 Тогда
						ПротоколЗапроса.ЗаголовкиОтвета.Вставить(Сред(Стр, 2, Раздел - 2), Сред(Стр, Раздел + 2));
						Продолжить;
					Иначе
						ОжидаемЗаголовкиОтвета = Ложь;
					КонецЕсли;
				КонецЕсли;
				ТекстОтвета.ДобавитьСтроку(Сред(Стр, 2));
			КонецЦикла;
			Если СтрНайти(Стр, "autoanswer") Тогда
				ПротоколЗапроса.Автоответ = Истина;
			КонецЕсли;
			ПротоколЗапроса.ТелоОтветаСтрокой = ТекстОтвета.ПолучитьТекст();
			Если КонтентСодержитТекст(ПротоколЗапроса.ЗаголовкиОтвета) Тогда
				ПротоколЗапроса.ТелоОтвета = ПолучитьДвоичныеДанныеИзСтроки(ПротоколЗапроса.ТелоОтветаСтрокой);
			Иначе
				ПротоколЗапроса.ТелоОтвета = Base64Значение(ПротоколЗапроса.ТелоОтветаСтрокой);
			КонецЕсли;
			ПротоколЗапроса.РазмерОтвета = ПротоколЗапроса.ТелоОтвета.Размер()/1000;
			Продолжить;
		КонецЕсли;
		
		Если ПустаяСтрока(Стр) Тогда
			Продолжить;
		КонецЕсли;
		
		СоединитьСтроки(ПротоколЗапроса.ПолныйТекст, Стр);
		СоединитьСтроки(ПротоколЗапроса.ТелоЗапросаСтрокой, Стр);
		
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ПротоколЗапроса.Адрес) Тогда
		ПротоколЗапроса.ТелоЗапроса = ПолучитьДвоичныеДанныеИзСтроки(ПротоколЗапроса.ТелоЗапросаСтрокой);
		СписокЗапросов.Добавить(ПротоколЗапроса);
	КонецЕсли;
	
	Возврат СписокЗапросов;
	
КонецФункции

#Область Конструкторы

Функция НовоеСодержаниеЗапроса()
	
	Содержание = Новый Структура;
	Содержание.Вставить("ЗаголовкиЗапроса");
	Содержание.Вставить("ТелоЗапроса");
	Содержание.Вставить("ЗаголовкиОтвета");
	Содержание.Вставить("ТелоОтвета");
	
	Возврат Содержание;

КонецФункции

#КонецОбласти

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//                       <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//  Структура - составные части URI согласно формату:
//   * Схема         - Строка - схема из URI.
//   * Логин         - Строка - логин из URI.
//   * Пароль        - Строка - пароль из URI.
//   * ИмяСервера    - Строка - часть <хост>:<порт> из URI.
//   * Хост          - Строка - хост из URI.
//   * Порт          - Строка - порт из URI.
//   * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> из URI.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@", НаправлениеПоиска.СКонца);
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

Процедура СоединитьСтроки(Строка1, Знач Строка2, Знач Разделитель = Неопределено)
	
	Если Разделитель = Неопределено Тогда
		Разделитель = Символы.ПС;
	КонецЕсли;
	Строка1 = Строка1 + ?(ПустаяСтрока(Строка1), "", Разделитель) + Строка2;
	
КонецПроцедуры

Процедура ПрочитатьЗаголовокОтветаВПротоколЗапроса(Стр, ПротоколЗапроса)
	
	// КодСостояния
	ПозицияПробел = СтрНайти(Стр, " ");
	Подстрока = Сред(Стр, ПозицияПробел + 1);
	ПозицияПробел2 = СтрНайти(Подстрока, " ");
	ПодстрокаКодСостояния = Лев(Подстрока, ПозицияПробел2 - 1);
	Если ВРег(ПодстрокаКодСостояния) <> "ERROR" Тогда
		Попытка
			ПротоколЗапроса.КодОтвета = Число(ПодстрокаКодСостояния);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	// Дата
	ПозицияДатаВремя = СтрНайти(Стр, " - ");
	Если ПозицияДатаВремя Тогда
		ПодстрокаДата = Сред(Стр, ПозицияДатаВремя + 3, 19);
		ПодстрокаМиллисекунды = Сред(Стр, ПозицияДатаВремя + 19 + 4);
		Миллисекунды = 0;
		ПозицияДлительность = СтрНайти(ПодстрокаМиллисекунды, " (");
		Если ПозицияДлительность Тогда
			ПодстрокаДлительность = Сред(ПодстрокаМиллисекунды, ПозицияДлительность + 2);
			ПодстрокаМиллисекунды = Лев(ПодстрокаМиллисекунды, ПозицияДлительность - 1);
			Миллисекунды = Число(ПодстрокаМиллисекунды);
			ПозицияКонецДлительность = СтрНайти(ПодстрокаДлительность, " ");
			ПодстрокаДлительность = Лев(ПодстрокаДлительность, ПозицияКонецДлительность - 1);
			ПротоколЗапроса.Длительность = Число(ПодстрокаДлительность);
		КонецЕсли;
		ПротоколЗапроса.Дата = Дата(ПодстрокаДата);
		ПротоколЗапроса.ВремяНачала = (ПротоколЗапроса.Дата - Дата(1,1,1)) * 1000 + Миллисекунды;
	Иначе
		ПротоколЗапроса.Дата = ТекущаяДатаСеанса();
	КонецЕсли;
	ПротоколЗапроса.ВремяНачала = (УниверсальноеВремя(ПротоколЗапроса.Дата) - Дата(1,1,1)) * 1000 + Миллисекунды;
	
КонецПроцедуры

#Область ВыполнениеЗапроса

// Выполнение произвольного запроса.

// Параметры:
//   ТекстЗапроса - Строка - строка запроса сервиса
//   Отказ - Булево - результат исполнения.
//   ТекстОшибки - Строка -возвращаемая ошибка.
//   КлючЗаписиЛога - Структура - отбор записи логов.
//
// Пример ПроизвольныйЗапрос:
//   GET http://localhost:90/edi/1112/customer/orders/ab93973c-c286-4824-8d33-5b1f343f6130
//   Accept: application/vnd-1cbn-cust-ordrs.en-edi-v1.1+json
//
Процедура ВыполнитьЗапросПоСтроке(Знач ТекстЗапроса, Отказ, ТекстОшибки = "", КлючЗаписиЛога = Неопределено) Экспорт
	
	Если ПустаяСтрока(ТекстЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	КэшОтветов = Новый Массив;
	КлючНачалаЗапроса = "### ";
	Пока Истина Цикл
		ПозицияВторогоРазделителя = СтрНайти(ТекстЗапроса, КлючНачалаЗапроса,,, 2);
		Если ПозицияВторогоРазделителя = 0 Тогда
			ВыполнитьЗапросHTTP(ТекстЗапроса, КэшОтветов, КлючЗаписиЛога, Отказ, ТекстОшибки);
			Прервать;
		Иначе
			ВложенныйТекст = Лев(ТекстЗапроса, ПозицияВторогоРазделителя - 1);
			ВыполнитьЗапросHTTP(ВложенныйТекст, КэшОтветов, КлючЗаписиЛога, Отказ, ТекстОшибки);
			ТекстЗапроса = Сред(ТекстЗапроса, ПозицияВторогоРазделителя);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ВыполнитьЗапросHTTP(СтрокаЗапроса, КэшОтветов, КлючЗаписиЛога, Отказ, ТекстОшибки)
	
	//СтруктураURL = Новый Структура;
	ПроверитьУстановитьПеременныеВСтроке(СтрокаЗапроса, КэшОтветов);
	СписокПротоколов = ПрочитатьПротоколыЗапросовИзСтроки(СтрокаЗапроса);
	Если СписокПротоколов = Неопределено Или СписокПротоколов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	ПротоколЗапроса = СписокПротоколов[0];
	
	// Проверка авторизации в запросе.
	Если ПустаяСтрока(ПротоколЗапроса.Логин) Тогда
		Авторизация = ПротоколЗапроса.ЗаголовкиЗапроса.Получить("Autorization");
		Если Авторизация <> Неопределено И СтрНачинаетсяС(Авторизация, "Basic ") Тогда
			СтрокаПоиска = Сред(Авторизация, 7);
			ЛогинПароль = ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(СтрокаПоиска));
			МассивРазделения = СтрРазделить(ЛогинПароль, ":");
			Если МассивРазделения.Количество() = 2 Тогда
				ПротоколЗапроса.Логин = МассивРазделения[0];
				ПротоколЗапроса.Пароль = МассивРазделения[1];
				ПротоколЗапроса.ЗаголовкиЗапроса.Удалить("Autorization");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Соединение = НовоеHTTPСоединениеПоПараметрам(ПротоколЗапроса);
	
	Запрос = Новый HTTPЗапрос(ПротоколЗапроса.Адрес);
	Для каждого ЭлементКоллекции Из ПротоколЗапроса.ЗаголовкиЗапроса Цикл
		Запрос.Заголовки.Вставить(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
	КонецЦикла;
	
	Запрос.УстановитьТелоИзДвоичныхДанных(ПротоколЗапроса.ТелоЗапроса);
	Попытка
		
		Ответ = _HTTPСоединение._ВызватьHTTPМетод(Соединение, Строка(ПротоколЗапроса.Метод), Запрос, , ПротоколЗапроса.Событие);
		
		ТипКонтента = ТипКонтентаОтвета(Ответ);
		Если ТипКонтента = Неопределено Или СтрНайти(ТипКонтента, "image") Тогда
			КэшОтветов.Добавить();
		Иначе
			КэшОтветов.Добавить(ЗначениеИзСтрокиJSON(Ответ.ПолучитьТелоКакСтроку()));
		КонецЕсли;
		
	Исключение
		
		Отказ = Истина;
		ТекстОшибки = 
			НСтр("ru = 'Ошибка выполнения запроса к сервису.'") + Символы.ПС
			+ ПолучитьСтрокуURLЗапроса(ПротоколЗапроса.Метод, ПротоколЗапроса.Сервер,
				ПротоколЗапроса.ЭтоЗащищенноеСоединение, ПротоколЗапроса.Порт, ПротоколЗапроса.Адрес)
			+ Символы.ПС
			+ ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			
	КонецПопытки;
	
КонецПроцедуры

Функция ТипКонтентаОтвета(Ответ)
	
	Если Ответ = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Ответ.Заголовки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Ответ.Заголовки.Получить("Content-Type");
	
КонецФункции

#КонецОбласти

// Выполняется поиск по маске {{[....}}, например {{[0].ticket}}
Процедура ПроверитьУстановитьПеременныеВСтроке(СтрокаПроверки, КэшРезультатов) Экспорт
	
	Если СтрЧислоВхождений(СтрокаПроверки, "{{[") > 0 Тогда
		
		МассивЗамен = Новый Массив;
		Для ИндексВхождения = 1 По СтрЧислоВхождений(СтрокаПроверки, "{{[") Цикл
			СтрокаПоиска = Сред(СтрокаПроверки, СтрНайти(СтрокаПроверки, "{{[",,, ИндексВхождения));
			СтрокаПоиска = Лев(СтрокаПоиска, СтрНайти(СтрокаПоиска, "}}",,, 1) + 1);
			Если ПустаяСтрока(СтрокаПоиска) Тогда
				Продолжить;
			КонецЕсли;
			СтрокаВыражения = Сред(СтрокаПоиска, 3, СтрДлина(СтрокаПоиска) - 4);
			Попытка
				СтрокаЗамены = Вычислить("КэшРезультатов" + СтрокаВыражения);
			Исключение
				СтрокаЗамены = "=== ERROR [" + СтрокаВыражения + "===";
			КонецПопытки;
			МассивЗамен.Добавить(Новый Структура("Ключ, Значение",
				СтрокаПоиска, СтрокаЗамены));
		КонецЦикла;
			
		Если МассивЗамен.Количество() > 0 Тогда
			Для каждого ЭлементКоллекции Из МассивЗамен Цикл
				СтрокаПроверки = СтрЗаменить(СтрокаПроверки, ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
			КонецЦикла;
		КонецЕсли;
		
	ИначеЕсли СтрНайти(СтрокаПроверки, "{{") > 0 Тогда
		
		// Параметры в адресной строке.
		Если СтрНайти(СтрокаПроверки, "{{$guid}}") <> 0 Тогда
			СтрокаПроверки = СтрЗаменить(СтрокаПроверки, "{{$guid}}",
				Строка(Новый УникальныйИдентификатор));
		ИначеЕсли СтрНайти(СтрокаПроверки, "{{$time}}") <> 0 Тогда
			СтрокаПроверки = СтрЗаменить(СтрокаПроверки, "{{$time}}",
				Строка(ТекущаяУниверсальнаяДатаВМиллисекундах()));
		ИначеЕсли СтрНайти(СтрокаПроверки, "{{") <> 0 Тогда
			ТегНачала = "{{";
			ТегОкончания = "}}";
			ИндексНачала = СтрНайти(СтрокаПроверки, ТегНачала);
			Подстрока = Сред(СтрокаПроверки, ИндексНачала + СтрДлина(ТегНачала));
			ИндексОкончания = СтрНайти(Подстрока, ТегОкончания);
			СтрокаВычисления = Лев(Подстрока, ИндексОкончания - 1);
			СтрокаЗамены = Сред(СтрокаПроверки, ИндексНачала, СтрДлина(ТегНачала) + ИндексОкончания);
			Значение = Вычислить(СтрокаВычисления);
			СтрокаПроверки = СтрЗаменить(СтрокаПроверки, СтрокаЗамены, Значение);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция НовоеHTTPСоединениеПоПараметрам(ПараметрыЗапроса)
	
	Если ПараметрыЗапроса.ЭтоЗащищенноеСоединение Тогда
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	Иначе
		ЗащищенноеСоединение = Неопределено;
	КонецЕсли;
	
	Попытка
		Соединение = Новый HTTPСоединение(ПараметрыЗапроса.Сервер, ПараметрыЗапроса.Порт,
			ПараметрыЗапроса.Логин, ПараметрыЗапроса.Пароль, ПараметрыЗапроса.Прокси, ПараметрыЗапроса.Таймаут,
			ЗащищенноеСоединение);
		Возврат Соединение;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

// Данные для записи исключения.
// 
// Параметры:
//  ЛогЗапроса - см. РегистрыСведений.ЛогиТрафика.НовыйЛогЗапроса
// 
// Возвращаемое значение:
//  Строка -  Данные для записи исключения
//
Функция ДанныеДляЗаписиИсключения(ЛогЗапроса) Экспорт
	
	СтруктураЗаписиДляЖурналаРегистрации = ОбщегоНазначения.СкопироватьРекурсивно(ЛогЗапроса);
//	СтруктураЗаписиДляЖурналаРегистрации.Удалить("Содержание");
//	СтруктураЗаписиДляЖурналаРегистрации.Удалить("Содержание");
	СтруктураЗаписиДляЖурналаРегистрации.Метод = Строка(СтруктураЗаписиДляЖурналаРегистрации.Метод);
	ДанныеДляЗаписиИсключения = ЗначениеВJSON(СтруктураЗаписиДляЖурналаРегистрации);
	
	Возврат ДанныеДляЗаписиИсключения;
	
КонецФункции

#КонецОбласти
